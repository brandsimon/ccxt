# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.binancedex_pb2 import create_order_msg, cancel_order_msg, Wallet


class binancedex (Exchange):

    def describe(self):
        return self.deep_extend(super(binancedex, self).describe(), {
            'id': 'binancedex',
            'name': 'Binance DEX',
            'countries': ['GB', 'EU'],
            'rateLimit': 200,
            'version': 'v1',
            'has': {
                'cancelAllOrders': False,
                'cancelOrder': False,
                'cancelOrders': False,
                'CORS': False,
                'createDepositAddress': False,
                'createLimitOrder': False,
                'createMarketOrder': False,
                'createOrder': False,
                'deposit': False,
                'editOrder': False,
                'fetchBalance': False,
                'fetchBidsAsks': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': False,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'privateAPI': True,
                'publicAPI': True,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1M',
            },
            'urls': {
                'logo': '',
                'api': 'https://dex.binance.org/',
                'www': 'https://binance.org/',
                'doc': 'https://docs.binance.org/api-reference/',
                'fees': 'https://docs.binance.org/trading-spec.html',
            },
            'fees': {
                'trading': {
                },
                'funding': {
                },
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'ticker/24hr',
                        'depth',
                        'klines',
                        'orders/{id}',
                        'account/{address}',
                    ],
                },
                'private': {
                    'post': [
                        'broadcast/?sync=1',
                    ],
                },
            },
            'commonCurrencies': {
            },
            'precisionMode': TICK_SIZE,
            'requiredCredentials': {
                'apiKey': False,
                'secret': False,
                'privateKey': True,
                'walletAddress': True,
            },
            'accountInfo': {},
            'exceptions': {
                'exact': {
                },
                'broad': {
                    'signature verification failed': AuthenticationError,
                },
            },
            'options': {
                'orderTypes': {
                    'limit': 2,
                },
                'orderSide': {
                    'buy': 1,
                    'sell': 2,
                },
            },
        })

    def fetch_markets(self, params={}):
        markets = self.publicGetMarkets(params)
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            baseSymbol = self.safe_string(market, 'base_asset_symbol')
            quoteSymbol = self.safe_string(market, 'quote_asset_symbol')
            lotSize = self.safe_float(market, 'lot_size')
            tickSize = self.safe_float(market, 'tick_size')
            originalBaseSymbol = baseSymbol.split('-')[0]
            originalQuoteSymbol = quoteSymbol.split('-')[0]
            symbol = originalBaseSymbol + '/' + originalQuoteSymbol
            id = baseSymbol + '_' + quoteSymbol
            result.append({
                'id': id,
                'symbol': symbol,
                'base': originalBaseSymbol,
                'quote': originalQuoteSymbol,
                'baseId': baseSymbol,
                'quoteId': quoteSymbol,
                'info': market,
                'precision': {
                    'amount': lotSize,
                    'price': tickSize,
                },
                'limits': {
                    'amount': {
                        'min': lotSize,
                        'max': None,
                    },
                    'price': {
                        'min': tickSize,
                        'max': None,
                    },
                    'cost': {
                        'min': 0,
                        'max': None,
                    },
                },
            })
        return result

    def parse_ticker(self, ticker, market=None):
        lastPrice = self.safe_float(ticker, 'lastPrice')
        weightedAvgPrice = self.safe_float(ticker, 'weightedAvgPrice')
        timestamp = self.safe_integer(ticker, 'closeTime')
        return {
            'symbol': self.markets_by_id[self.safe_string(ticker, 'symbol')]['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'highPrice'),
            'low': self.safe_float(ticker, 'lowPrice'),
            'bid': self.safe_float(ticker, 'bidPrice'),
            'bidVolume': self.safe_float(ticker, 'bidQuantity'),
            'ask': self.safe_float(ticker, 'askPrice'),
            'askVolume': self.safe_float(ticker, 'askQuantity'),
            'vwap': weightedAvgPrice,
            'open': self.safe_float(ticker, 'openPrice'),
            'close': lastPrice,
            'last': lastPrice,
            'previousClose': self.safe_float(ticker, 'prevClosePrice'),
            'change': self.safe_float(ticker, 'priceChange'),
            'percentage': self.safe_float(ticker, 'priceChangePercent'),
            'average': weightedAvgPrice,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': self.safe_float(ticker, 'quoteVolume'),
            'info': ticker,
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        tickers = self.publicGetTicker24hr(self.extend(request, params))
        return self.parse_ticker(tickers[0], None)

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        tickers = self.publicGetTicker24hr(params)
        return self.parse_tickers(tickers, symbols)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            self.safe_float(ohlcv, 0),
            self.safe_float(ohlcv, 1),
            self.safe_float(ohlcv, 2),
            self.safe_float(ohlcv, 3),
            self.safe_float(ohlcv, 4),
            self.safe_float(ohlcv, 7),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': timeframe,
        }
        # default = 300, max = 1000
        if limit is not None:
            request['limit'] = limit
        if since is not None:
            request['startTime'] = since
        response = self.publicGetKlines(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def fetch_balance(self, params={}):
        self.check_required_credentials()
        self.load_markets()
        request = {
            'address': self.walletAddress,
        }
        response = self.publicGetAccountAddress(self.extend(request, params))
        balances = response['balances']
        result = {'info': response}
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'symbol')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            free = self.safe_float(balance, 'free')
            frozen = self.safe_float(balance, 'frozen')
            locked = self.safe_float(balance, 'locked')
            account['free'] = free
            account['used'] = locked
            account['total'] = free + frozen + locked
            result[code] = account
        return self.parse_balance(result)

    def fetch_account_info(self, params={}):
        request = {
            'address': self.walletAddress,
        }
        response = self.publicGetAccountAddress(self.extend(request, params))
        self.accountInfo = {
            'sequence': response['sequence'],
            'public_key': response['public_key'],
            'account_number': response['account_number'],
            'wallet': Wallet(private_key=self.privateKey,
                             account_number=response['account_number'],
                             address=self.walletAddress,
                             sequence=response['sequence']),
        }
        return self.accountInfo

    def is_account_info_available(self):
        keys = list(self.accountInfo.keys())
        return len(keys) == 4

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        orderbook = self.publicGetDepth(self.extend(request, params))
        return self.parse_order_book(orderbook, None, 'bids', 'asks', 0, 1)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type != 'limit':
            raise ExchangeError(self.id + ' allows limit orders only')
        self.load_markets()
        market = self.market(symbol)
        order_type = 2
        if not self.is_account_info_available():
            self.fetch_account_info()
        order_side = 1
        if side == 'sell':
            order_side = 2
        msg = {
            'body': create_order_msg(self.accountInfo['wallet'], market['id'], order_type, order_side, amount, price),
        }
        response = self.privatePostBroadcastSync1(msg)
        self.accountInfo['wallet'].increment_sequence()
        return {
            'info': response,
            'id': self.parse_json(response[0]['data'])['order_id'],
        }

    def cancel_order(self, id, symbol=None, params={}):
        if not self.is_account_info_available():
            self.fetch_account_info()
        self.load_markets()
        market = self.market(symbol)
        msg = {
            'body': cancel_order_msg(self.accountInfo['wallet'], id, market['id']),
        }
        result = {
            'info': self.privatePostBroadcastSync1(msg),
        }
        self.accountInfo['wallet'].increment_sequence()
        return result

    def parse_order(self, order, market=None):
        orderStatusMap = {
            'FullyFill': 'closed',
            'Canceled': 'canceled',
            'PartialFill': 'open',
            'Ack': 'open',
            'Expired': 'canceled',
            'FailedBlocking': 'canceled',
            'FailedMatching': 'canceled',
            'IocExpire': 'canceled',
            'IocNoFill': 'canceled',
        }
        status = None
        orderStatus = self.safe_string(order, 'status', None)
        if orderStatus in orderStatusMap:
            status = orderStatusMap[orderStatus]
        side = 'buy'
        if order['direction'] == self.options['orderSide']['sell']:
            side = 'sell'
        marketId = self.safe_string(order, 'symbol')
        symbol = None
        if marketId in self.markets_by_id:
            marketInfo = self.markets_by_id[marketId]
            symbol = marketInfo['symbol']
        orderType = 'market'
        if order['orderType'] == self.options['orderTypes']['limit']:
            orderType = 'limit'
        timestamp = self.parse8601(self.safe_string(order, 'orderCreateTime'))
        quantity = self.safe_float(order, 'quantity')
        filledQuantity = self.safe_float(order, 'cumulateQuantity')
        price = self.safe_float(order, 'price')
        id = self.safe_string(order, 'orderId')
        feeInfo = self.safe_string(order, 'fee').split(':')
        feeSymbol = self.currencies_by_id[self.safe_string(feeInfo, 0)]['code']
        return {
            'info': order,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': orderType,
            'side': side,
            'price': price,
            'average': None,
            'amount': quantity,
            'remaining': quantity - filledQuantity,
            'filled': filledQuantity,
            'status': status,
            'fee': {
                'cost': float(self.safe_string(feeInfo, 1)),
                'currency': feeSymbol,
            },
        }

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': id,
        }
        response = self.publicGetOrdersId(self.extend(request, params))
        return self.parse_order(response, symbol)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + 'api/v1/' + self.implode_params(path, params)
        if method == 'GET':
            if params:
                url += '?' + self.urlencode(params)
        else:
            if api == 'private':
                body = params['body']
                headers = {
                    'Content-type': 'text/plain',
                }
            else:
                body = self.json(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response):
        if not response or httpCode == 200:
            return  # fallback to default error handler
        error = self.safe_value(response, 'message')
        if error:
            feedback = self.id + ' ' + self.json(response)
            exact = self.exceptions['exact']
            if error in exact:
                raise exact[error](feedback)
            broad = self.exceptions['broad']
            broadKey = self.findBroadlyMatchedKey(broad, error)
            if broadKey is not None:
                raise broad[broadKey](feedback)
            raise ExchangeError(feedback)  # unknown error
