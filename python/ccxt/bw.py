# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.decimal_to_precision import DECIMAL_PLACES


class bw (Exchange):

    def describe(self):
        return self.deep_extend(super(bw, self).describe(), {
            'id': 'bw',
            'name': 'bw.com',
            'countries': ['CN'],
            'rateLimit': 1500,
            'version': 'v1',
            'has': {
                'cancelAllOrders': False,
                'cancelOrder': True,
                'cancelOrders': False,
                'CORS': False,
                'createDepositAddress': False,
                'createLimitOrder': True,
                'createMarketOrder': False,
                'createOrder': True,
                'deposit': False,
                'editOrder': False,
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchClosedOrders': False,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchL2OrderBook': False,
                'fetchLedger': False,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': True,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': False,
                'fetchOrders': False,
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTradingLimits': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'privateAPI': False,
                'publicAPI': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1M',
                '5m': '5M',
                '15m': '15M',
                '30m': '30M',
                '1h': '1H',
                '1w': '1W',
            },
            'urls': {
                'api': 'https://www.bw.com/',
                'www': 'https://www.bw.com',
                'doc': 'https://www.bw.com/restApi',
                'fees': 'https://www.bw.com/feesRate',
                'referral': '',
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'fees': {
                'trading': {
                    'tierBased': True,
                    'percentage': True,
                    'taker': 0.1 / 100,
                    'maker': 0.1 / 100,
                    'tiers': {
                        'taker': [
                            [0, 0.1 / 100],
                        ],
                        'maker': [
                            [0, 0.1 / 100],
                        ],
                    },
                },
                'funding': {
                },
            },
            'exceptions': {
                'exact': {
                    '999': AuthenticationError,
                },
            },
            'api': {
                'public': {
                    'get': [
                        'exchange/config/controller/website/marketcontroller/getByWebId',
                        'exchange/config/controller/website/currencycontroller/getCurrencyList',
                        'api/data/v1/entrusts',
                        'api/data/v1/klines',
                    ],
                },
                'private': {
                    'get': [
                        'exchange/entrust/controller/website/EntrustController/getEntrustById',
                    ],
                    'post': [
                        'exchange/fund/controller/website/fundcontroller/findbypage',
                        'exchange/entrust/controller/website/EntrustController/addEntrust',
                        'exchange/entrust/controller/website/EntrustController/cancelEntrust',
                    ],
                },
            },
            'commonCurrencies': {
            },
            'precisionMode': DECIMAL_PLACES,
            'options': {
            },
        })

    def fetch_markets(self, params={}):
        response = self.publicGetExchangeConfigControllerWebsiteMarketcontrollerGetByWebId(params)
        markets = self.safe_value(response, 'datas', [])
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            id = self.safe_string(market, 'marketId')
            numericId = int(id)
            name = self.safe_string_upper(market, 'name')
            base, quote = name.split('_')
            base = self.safe_currency_code(base)
            quote = self.safe_currency_code(quote)
            baseId = self.safe_string(market, 'sellerCurrencyId')
            quoteId = self.safe_string(market, 'buyerCurrencyId')
            baseNumericId = int(baseId)
            quoteNumericId = int(quoteId)
            symbol = base + '/' + quote
            state = self.safe_integer(market, 'state')
            active = state == 1
            result.append({
                'id': id,
                'active': active,
                'numericId': numericId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'baseNumericId': baseNumericId,
                'quoteNumericId': quoteNumericId,
                'info': market,
                'precision': {
                    'amount': self.safe_integer(market, 'amountDecimal'),
                    'price': self.safe_integer(market, 'priceDecimal'),
                },
                'limits': {
                    'amount': {
                        'min': self.safe_float(market, 'minAmount'),
                        'max': None,
                    },
                    'price': {
                        'min': 0,
                        'max': None,
                    },
                    'cost': {
                        'min': 0,
                        'max': None,
                    },
                },
            })
        return result

    def fetch_currencies(self, params={}):
        response = self.publicGetExchangeConfigControllerWebsiteCurrencycontrollerGetCurrencyList(params)
        currencies = self.safe_value(response, 'datas', [])
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            id = self.safe_string(currency, 'currencyId')
            code = self.safe_currency_code(self.safe_string_upper(currency, 'name'))
            state = self.safe_integer(currency, 'state')
            active = state == 1
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': code,
                'active': active,
                'fee': None,
                'precision': None,
                'limits': {
                    'amount': {
                        'min': float(self.safe_integer(currency, 'limitAmount', 0)),
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': float(self.safe_integer(currency, 'onceDrawLimit')),
                    },
                },
            }
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'marketId': market['id'],
        }
        if limit is not None:
            request['dataSize'] = limit
        response = self.publicGetApiDataV1Entrusts(self.extend(request, params))
        orderbook = self.safe_value(response, 'datas', [])
        ts = self.safe_timestamp(orderbook, 'timestamp')
        return self.parse_order_book(orderbook, ts, 'bids', 'asks', 0, 1)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privatePostExchangeFundControllerWebsiteFundcontrollerFindbypage(params)
        data = self.safe_value(response, 'datas', {})
        balances = self.safe_value(data, 'list', [])
        result = {'info': response}
        for i in range(0, len(balances)):
            balance = balances[i]
            symbol = self.safe_integer(balance, 'currencyTypeId', '')
            symbol = str(symbol)
            if symbol in self.currencies_by_id:
                symbol = self.currencies_by_id[symbol]['code']
                symbol = self.safe_currency_code(symbol)
            account = self.account()
            amount = self.safe_float(balance, 'amount')
            account['free'] = amount
            account['total'] = amount
            account['used'] = 0
            result[symbol] = account
        return self.parse_balance(result)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        if price is None:
            raise ExchangeError(self.id + ' allows limit orders only')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'amount': self.amount_to_precision(symbol, amount),
            'price': self.price_to_precision(symbol, price),
            'type': 0,  # sell
            'rangeType': 0,  # limit order
            'marketId': market['id'],
        }
        if side.lower() == 'buy':
            request['type'] = 1  # buy
        response = self.privatePostExchangeEntrustControllerWebsiteEntrustControllerAddEntrust(self.extend(request, params))
        data = self.safe_value(response, 'datas')
        return {
            'id': self.safe_string(data, 'entrustId'),
            'info': response,
        }

    def parse_order_status(self, status):
        statuses = {
            '-2': 'canceled',
            '-1': 'canceled',
            '0': 'open',
            '1': 'canceled',
            '2': 'closed',
            '3': 'open',
            '4': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        marketId = self.safe_string(order, 'marketId')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        timestamp = self.safe_integer(order, 'createTime')
        side = None
        orderSide = self.safe_integer(order, 'type')
        if orderSide == 0:
            side = 'sell'
        elif orderSide == 1:
            side = 'buy'
        amount = self.safe_float(order, 'amount')
        price = self.safe_float(order, 'price')
        filled = self.safe_float(order, 'completeAmount')
        status = self.parse_order_status(self.safe_integer(order, 'status', str('')))
        return {
            'info': order,
            'id': self.safe_string(order, 'entrustId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': self.safe_string(market, 'symbol'),
            'type': 'limit',
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'average': None,
            'filled': filled,
            'remaining': amount - filled,
            'status': status,
            'fee': None,
            'trades': None,
        }

    def fetch_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'marketId': market['id'],
            'entrustId': id,
        }
        response = self.privateGetExchangeEntrustControllerWebsiteEntrustControllerGetEntrustById(self.extend(request, params))
        order = self.safe_value(response, 'datas', {})
        return self.parse_order(order, market)

    def cancel_order(self, id, symbol=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' cancelOrder requires a symbol argument')
        self.load_markets()
        market = self.market(symbol)
        request = {
            'marketId': market['id'],
            'entrustId': id,
        }
        response = self.privatePostExchangeEntrustControllerWebsiteEntrustControllerCancelEntrust(self.extend(request, params))
        return {
            'info': response,
            'id': id,
        }

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        return [
            int(self.safe_float(ohlcv, 3) * 1000),
            self.safe_float(ohlcv, 4),
            self.safe_float(ohlcv, 5),
            self.safe_float(ohlcv, 6),
            self.safe_float(ohlcv, 7),
            self.safe_float(ohlcv, 8),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'marketId': market['id'],
            'type': self.timeframes[timeframe],
            'dataSize': 500,
        }
        if limit is not None:
            request['dataSize'] = limit
        response = self.publicGetApiDataV1Klines(self.extend(request, params))
        data = self.safe_value(response, 'datas', [])
        ohlcvs = self.parse_ohlcvs(data, market, timeframe, since, limit)
        return self.sort_by(ohlcvs, 0)

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'] + path
        if method == 'GET':
            if params:
                url += '?' + self.urlencode(params)
        else:
            body = self.json(params)
        if api == 'private':
            ms = str(self.milliseconds())
            content = ''
            if method == 'GET':
                sortedParams = self.keysort(params)
                keys = list(sortedParams.keys())
                for i in range(0, len(keys)):
                    key = keys[i]
                    content += key + sortedParams[key]
            else:
                content = body
            signing = self.apiKey + ms + content + self.secret
            hash = self.hash(self.encode(signing), 'md5')
            if not headers:
                headers = {}
            headers['Apiid'] = self.apiKey
            headers['Timestamp'] = ms
            headers['Sign'] = hash
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # default error handler
        resMsg = self.safe_value(response, 'resMsg')
        errorCode = self.safe_string(resMsg, 'code')
        if errorCode != '1':
            feedback = self.id + ' ' + self.json(response)
            exact = self.exceptions['exact']
            if errorCode in exact:
                raise exact[errorCode](feedback)
            raise ExchangeError(feedback)  # unknown error
