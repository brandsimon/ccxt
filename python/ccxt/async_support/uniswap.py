# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import OrderImmediatelyFillable
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import TICK_SIZE

import web3
from web3 import Web3
from uniswap import Uniswap
from eth_utils import decode_hex

ONE_ETH = 1 * 10 ** 18


class uniswap(Exchange):

    def describe(self):
        return self.deep_extend(super(uniswap, self).describe(), {
            'id': 'uniswap',
            'name': 'uniswap',
            'rateLimit': 500,
            'certified': False,
            'pro': False,
            # new metainfo interface
            'has': {
                'cancelAllOrders': False,
                'cancelOrder': True,
                'CORS': False,
                'createOrder': True,
                'fetchCurrencies': True,
                'fetchBalance': True,
                'fetchBidsAsks': False,
                'fetchClosedOrders': False,
                'fetchDepositAddress': False,
                'fetchDeposits': False,
                'fetchFundingFees': False,
                'fetchMarkets': True,
                'fetchMyTrades': False,
                'fetchOHLCV': False,
                'fetchOpenOrders': False,
                'fetchOrder': True,
                'fetchOrders': False,
                'fetchOrderBook': True,
                'fetchStatus': False,
                'fetchTicker': False,
                'fetchTickers': False,
                'fetchTime': False,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTransactions': False,
                'fetchWithdrawals': False,
                'withdraw': False,
            },
            'timeframes': {
            },
            'precisionMode': TICK_SIZE,
            'urls': {
            },
            'api': {
            },
            'fees': {
            },
            'requiredCredentials': {
                'walletAddress': True,
                'privateKey': True,
                'apiKey': False,
                'secret': False,
            },
            'commonCurrencies': {
                'WETH': 'ETH',
            },
            'options': {
                'slippage': 0.01,
                'gasPrice': 90,
                'amount': 1,
                'deadline': 600,
                'provider': None,
            },
            'exceptions': {
            },
            'uniswap': None,
            'w3_instance': None,
        })

    async def get_w3(self):
        if not self.w3_instance:
            self.w3_instance = Web3(
                Web3.HTTPProvider(
                    self.options['provider'],
                    request_kwargs={"timeout": self.options['deadline'] + 10}))

            def gas_price_strategy(web3, transaction_params=None):
                return Web3.toWei(self.options['gasPrice'], 'gwei')

            self.w3_instance.eth.setGasPriceStrategy(gas_price_strategy)
        return self.w3_instance

    async def get_uniswap(self):
        if not self.uniswap:
            w3 = await self.get_w3()
            self.uniswap = Uniswap(
                version=2,
                address=self.walletAddress,
                private_key=self.privateKey,
                web3=w3,
                deadline=self.options['deadline'],
                max_slippage=self.options['slippage'])
        return self.uniswap

    async def fetch_markets(self, params={}):
        result = []
        for i in range(0, 1):
            address = '0x2F85E11f6F12eaD6Af643F083a34E001030D2a6F'
            baseId = 'LPOOL'
            quoteId = 'ETH'
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': 1 / ONE_ETH,
                'price': 1 / ONE_ETH,
            }
            active = True
            entry = {
                'id': id,
                'address': address,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': {},
                'type': None,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            }
            result.append(entry)
        return result

    async def fetch_currencies(self, params={}):
        result = {}
        response = {
            'ETH': '0x0000000000000000000000000000000000000000',
            'LPOOL': '0x6149C26Cd2f7b5CCdb32029aF817123F6E37Df5B',
            'USDT': '0xdAC17F958D2ee523a2206206994597C13D831ec7',
        }
        for id in response:
            address = response[id]
            code = self.safe_currency_code(id)
            name = code
            precision = None
            isWithdrawEnabled = True
            isDepositEnabled = True
            fees = {}
            fee = None
            active = True
            result[code] = {
                'id': id,
                'name': name,
                'address': address,
                'code': code,
                'precision': precision,
                'info': {},
                'active': active,
                'fee': fee,
                'fees': fees,
                'limits': {},
            }
        return result

    async def fetch_balance(self, params={}):
        await self.load_markets()
        result = {'info': {}}
        uniswap = await self.get_uniswap()

        for code in self.currencies:
            currency = self.currencies[code]
            address = currency['address']
            code = currency['code']
            account = self.account()
            b = uniswap.get_token_balance(address)
            account['free'] = b / ONE_ETH
            account['used'] = b / ONE_ETH
            account['total'] = b / ONE_ETH
            result[code] = account
        return self.parse_balance(result)

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        base = market['base']
        base_currency = self.currency(base)
        address = base_currency['address']
        uniswap = await self.get_uniswap()
        amount = self.options['amount']
        real_amount = int(amount * ONE_ETH)
        return {
            'asks': [[uniswap.get_eth_token_output_price(address, real_amount) / real_amount,
                      amount]],
            'bids': [[uniswap.get_token_eth_input_price(address, real_amount) / real_amount,
                      amount]],
        }

    async def create_order(self, symbol, type, side, amount, price=None, params={}):
        if type != 'limit':
            raise ExchangeError(self.id + ' createOrder allows limit orders only')
        await self.load_markets()
        uniswap = await self.get_uniswap()

        market = self.market(symbol)
        orig_amount = amount
        amount = int(amount * ONE_ETH)
        market = self.market(symbol)
        base = self.currency(market['base'])
        qty = amount
        eth_qty = int(amount * price)
        deadline = uniswap._deadline()

        if side == 'sell':
            tx = uniswap.token_to_eth_swap_output(
                qty=qty, eth_qty=eth_qty, input_token=base['address'])
        else:
            tx = uniswap.eth_to_token_swap_output(
                qty=qty, eth_qty=eth_qty, output_token=base['address'])
        return {
            'info': {
                'deadline': deadline,
                'nonce': uniswap.last_nonce - 1,
            },
            'id': tx.hex(),
            'amount': orig_amount,
            'filled': 0,
            'side': side,
            'price': price,
            'symbol': symbol,
        }

    def fetch_unified_order(self, order, params={}):
        request = {
            'deadline': order['info']['deadline'],
            'nonce': order['info']['nonce'],
        }
        return self.fetch_order(order['id'], order['symbol'], self.extend(request, params))

    async def fetch_order(self, id, symbol=None, params={}):
        # deadline before actual execution
        # block = w3.eth.getBlock(transaction['blockNumber'])
        # info['deadline']
        # block['timestamp']
        await self.load_markets()
        uniswap = await self.get_uniswap()
        w3 = await self.get_w3()
        tx = decode_hex(id)
        deadline = self.safe_integer(params, 'deadline', 0)
        nonce = self.safe_integer(params, 'nonce')

        amount = int(self.options['amount'] * ONE_ETH)
        filled = 0
        price = None
        timestamp = None
        symbol = None
        side = None
        fee = 0
        status = 'open'

        transaction = None
        parsed = None
        receipt = None
        now = self.milliseconds() / 1000

        try:
            transaction = w3.eth.getTransaction(tx)
            parsed = uniswap.parse_transaction(transaction)

            side = parsed['side']
            if side == 'sell':
                amount = parsed['amountIn']
                price = parsed['amountOut'] / parsed['amountIn']
            else:
                amount = parsed['amountOut']
                price = parsed['amountIn'] / parsed['amountOut']
            timestamp = parsed['deadline'] * 1000

            try:
                receipt = w3.eth.getTransactionReceipt(tx)
                if receipt['status'] == 0:
                    status = 'canceled'
                elif receipt['blockNumber'] is None:
                    status = 'open'
                else:
                    status = 'closed'
                    filled = amount
                fee = receipt['gasUsed']
            except web3.exceptions.TransactionNotFound:
                pass

            base = self.safe_currency_code(parsed['base'])
            quote = self.safe_currency_code(parsed['quote'])
            symbol = base + '/' + quote
        except web3.exceptions.TransactionNotFound:
            if deadline < now:
                status = 'canceled'
            else:
                raise OrderNotFound('Not found, deadline not reached')

        return {
            'info': {
                'transaction': transaction,
                'parsed': parsed,
                'receipt': receipt,
                'deadline': deadline,
                'nonce': nonce,
            },
            'id': id,
            'clientOrderId': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': 'limit',
            'timeInForce': None,
            'side': side,
            'price': price,
            'amount': amount / ONE_ETH,
            'cost': filled * price / ONE_ETH if price else None,
            'average': None,
            'filled': filled / ONE_ETH,
            'remaining': (amount - filled) / ONE_ETH,
            'status': status,
            'fee': {
                'currency': 'ETH',
                'cost': fee / ONE_ETH,
            },
            'trades': None,
        }

    def cancel_unified_order(self, order, params={}):
        request = {
            'deadline': order['info']['deadline'],
            'nonce': order['info']['nonce'],
        }
        return self.cancel_order(order['id'], order['symbol'], self.extend(request, params))

    async def cancel_order(self, id, symbol=None, params={}):
        uniswap = await self.get_uniswap()
        w3 = await self.get_w3()
        now = self.milliseconds() / 1000
        tx = decode_hex(id)
        deadline = self.safe_integer(params, 'deadline', 0)
        nonce = self.safe_integer(params, 'nonce')
        try:
            transaction = w3.eth.getTransaction(tx)
            if transaction['blockNumber'] is not None:
                raise BadRequest('Order is mined already')
            nonce = transaction['nonce']
        except web3.exceptions.TransactionNotFound:
            if deadline < now:
                return

        gas_price = Web3.toWei(int(self.options['gasPrice'] * 1.15), 'gwei')
        cancel_tx = uniswap.cancel_transaction(nonce=nonce, gas_price=gas_price)
        w3.eth.waitForTransactionReceipt(cancel_tx, timeout=deadline - now)
